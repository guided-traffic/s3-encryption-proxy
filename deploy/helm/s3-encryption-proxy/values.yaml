# Default values for s3-encryption-proxy.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

replicaCount: 1

image:
  registry: docker.io
  repository: hansfischer/s3-encryption-proxy
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: ""

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

podAnnotations: {}

podLabels: {}

podSecurityContext:
  fsGroup: 1001
  runAsNonRoot: true
  runAsUser: 1001
  runAsGroup: 1001
  seccompProfile:
    type: RuntimeDefault

securityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
    - ALL
  readOnlyRootFilesystem: true
  runAsNonRoot: true
  runAsUser: 1001

service:
  type: ClusterIP
  port: 8080
  targetPort: 8080
  annotations: {}

ingress:
  enabled: false
  className: ""
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  hosts:
    - host: s3-proxy.local
      paths:
        - path: /
          pathType: Prefix
  tls: []
  #  - secretName: s3-proxy-tls
  #    hosts:
  #      - s3-proxy.local

# Certificate management with cert-manager
certificate:
  enabled: false
  issuer:
    # Use 'cluster-issuer' or 'issuer'
    kind: ClusterIssuer
    name: letsencrypt-prod
  dnsNames:
    - s3-proxy.local
  secretName: s3-proxy-tls
  annotations: {}

resources:
  limits:
    cpu: 500m
    memory: 512Mi
  requests:
    cpu: 250m
    memory: 256Mi

livenessProbe:
  httpGet:
    path: /health
    port: http
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3

readinessProbe:
  httpGet:
    path: /health
    port: http
  initialDelaySeconds: 5
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 3

autoscaling:
  enabled: false
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

# Additional volumes on the output Deployment definition.
volumes:
  - name: tmp
    emptyDir: {}

# Additional volumeMounts on the output Deployment definition.
volumeMounts:
  - name: config
    mountPath: /app/config
    readOnly: true
  - name: tmp
    mountPath: /tmp

nodeSelector: {}

tolerations: []

affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
    - weight: 100
      podAffinityTerm:
        labelSelector:
          matchExpressions:
          - key: app.kubernetes.io/name
            operator: In
            values:
            - s3-encryption-proxy
        topologyKey: kubernetes.io/hostname

# Network policy configuration
networkPolicy:
  enabled: false
  policyTypes:
    - Ingress
    - Egress
  ingress:
    - from: []
      ports:
        - protocol: TCP
          port: 8080
  egress:
    - to: []
      ports:
        - protocol: TCP
          port: 443  # HTTPS for S3 access
        - protocol: TCP
          port: 53   # DNS
        - protocol: UDP
          port: 53   # DNS

# Pod Disruption Budget
podDisruptionBudget:
  enabled: true
  minAvailable: 1
  # maxUnavailable: 1

# S3 Encryption Proxy Configuration
config:
  # Server configuration
  bindAddress: "0.0.0.0:8080"
  logLevel: "info"

  # Target S3 configuration
  targetEndpoint: "https://s3.amazonaws.com"
  region: "us-east-1"

  # TLS configuration
  tls:
    enabled: false
    certFile: ""
    keyFile: ""

  # Encryption configuration
  encryption:
    encryptionMethodAlias: "default"
    providers:
      - alias: "default"
        type: "aes"
        description: "Default AES envelope encryption"
        config:
          aes_key: "0123456789abcdef0123456789abcdef"
          metadata_key_prefix: "x-s3ep-"

# Environment variables (additional custom env vars can be added here)
env: []

# Secrets configuration
secrets:
  # S3 credentials
  s3:
    accessKeyId: ""
    secretKey: ""

  # GCP service account key (for Tink KMS)
  gcp:
    serviceAccountKey: ""

  # AWS credentials (for AWS KMS)
  aws:
    accessKeyId: ""
    secretAccessKey: ""

# License configuration
license:
  # Existing secret containing the license
  # If specified, this takes precedence over license.jwt
  existingSecret: ""
  # Key within the existingSecret that contains the license JWT
  existingSecretKey: "license.jwt"
  # Direct license JWT content (will be stored in generated secret)
  # Only used if existingSecret is not specified
  jwt: ""

# Monitoring
monitoring:
  # Enable Prometheus monitoring
  enabled: false
  # Port for monitoring endpoints
  port: 9090
  # Path for metrics endpoint
  metricsPath: /metrics
  # Service configuration for monitoring
  service:
    enabled: false
    type: ClusterIP
    port: 9090
    targetPort: 9090
    annotations: {}
  # ServiceMonitor for Prometheus Operator
  serviceMonitor:
    enabled: false
    namespace: monitoring
    interval: 30s
    scrapeTimeout: 10s
    labels: {}
    annotations: {}
    # Override port for ServiceMonitor (defaults to monitoring.port)
    port: ""
    # Override path for ServiceMonitor (defaults to monitoring.metricsPath)
    path: ""

  # Grafana Dashboard configuration
  grafana:
    dashboard:
      enabled: false
      # Namespace where dashboard ConfigMap should be created
      namespace: ""  # defaults to release namespace
      # Labels for dashboard discovery by Grafana
      labels:
        grafana_dashboard: "1"
        # Common labels for Grafana dashboard discovery
        # app.kubernetes.io/name: grafana
        # app.kubernetes.io/component: dashboard
        # Additional custom labels for specific Grafana instances
        # grafana-instance: "production"
        # dashboard-category: "monitoring"
        # team: "platform-engineering"
      # Custom annotations for the dashboard ConfigMap
      annotations: {}
        # Examples of custom annotations:
        # grafana-folder: "S3 Encryption Proxy"
        # grafana.com/dashboard-uid: "s3ep-performance"
        # grafana.com/auto-import: "true"
        # kubernetes.io/managed-by: "helm"
        # meta.helm.sh/release-name: "s3-encryption-proxy"
        # app.kubernetes.io/managed-by: "Helm"
        # config.kubernetes.io/local-config: "true"
        # description: "Performance monitoring dashboard for S3 Encryption Proxy"

# Logging
logging:
  enabled: false
  format: json
  level: info
